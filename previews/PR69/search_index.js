var documenterSearchIndex = {"docs":
[{"location":"affinemap/#Affine-maps","page":"Affine maps","title":"Affine maps","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"An affine map is a function f given by","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":" f(x) = A x + b","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"where A is the slope and b is the intercept. Different representations of affine maps are sometimes useful, as documented below.","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"affinemap/#Types","page":"Affine maps","title":"Types","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"AbstractAffineMap{T<:Number}\nAffineMap{T,U,V}\nLinearMap{T,U}\nAffineCorrector{T,U,V,S}","category":"page"},{"location":"affinemap/#MarkovKernels.AbstractAffineMap","page":"Affine maps","title":"MarkovKernels.AbstractAffineMap","text":"AbstractAffineMap{T<:Number}\n\nAbstract type for representing affine maps between vector spaces over the field determined by T.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.AffineMap","page":"Affine maps","title":"MarkovKernels.AffineMap","text":"AffineMap{T,U,V}\n\nType for representing affine maps in the standard slope / intercept parametrisation.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.LinearMap","page":"Affine maps","title":"MarkovKernels.LinearMap","text":"LinearMap{T,U}\n\nType for representing affine maps with zero intercept.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.AffineCorrector","page":"Affine maps","title":"MarkovKernels.AffineCorrector","text":"AffineCorrector{T,U,V,S}\n\nType for representing affine correctors, i.e.,\n\nx ↦ b + A * (x -c).\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#Constructors","page":"Affine maps","title":"Constructors","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"AffineMap(A::AbstractMatrix, b::AbstractVector)\nLinearMap(A::AbstractMatrix)\nAffineCorrector(A::AbstractMatrix, b::AbstractVector, c::AbstractVector)","category":"page"},{"location":"affinemap/#MarkovKernels.AffineMap-Tuple{AbstractMatrix, AbstractVector}","page":"Affine maps","title":"MarkovKernels.AffineMap","text":"AffineMap(A::AbstractMatrix, b::AbstractVector)\n\nCreates an AffineMap with slope A and intercept b.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.LinearMap-Tuple{AbstractMatrix}","page":"Affine maps","title":"MarkovKernels.LinearMap","text":"LinearMap(A::AbstractMatrix)\n\nCreates a LinearMap with slope A.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.AffineCorrector-Tuple{AbstractMatrix, AbstractVector, AbstractVector}","page":"Affine maps","title":"MarkovKernels.AffineCorrector","text":"AffineCorrector(A::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nCreates an Affine Corrector with slope A and intercept b - A * c.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#Basics","page":"Affine maps","title":"Basics","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"slope(F::AffineMap)\nintercept(F::AffineMap)\ncompose(F2::AbstractAffineMap, F1::AbstractAffineMap)\n*(F2::AbstractAffineMap, F1::AbstractAffineMap)","category":"page"},{"location":"affinemap/#MarkovKernels.slope-Tuple{AffineMap}","page":"Affine maps","title":"MarkovKernels.slope","text":"slope(F::AbstractAffineMap)\n\nComputes the slope of F.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.intercept-Tuple{AffineMap}","page":"Affine maps","title":"MarkovKernels.intercept","text":"intercept(F::AffineMap)\n\nComputes the intercept of F.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.compose-Tuple{AbstractAffineMap, AbstractAffineMap}","page":"Affine maps","title":"MarkovKernels.compose","text":"compose(F2::AbstractAffineMap, F1::AbstractAffineMap)\n\nComputes the affine map F3 resulting from the composition F2 ∘ F1.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#Base.:*-Tuple{AbstractAffineMap, AbstractAffineMap}","page":"Affine maps","title":"Base.:*","text":"*(F2::AbstractAffineMap, F1::AbstractAffineMap)\n\nEquivalent to compose(F2::AbstractAffineMap, F1::AbstractAffineMap).\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#NormalKernel","page":"NormalKernel","title":"NormalKernel","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"The Normal kernel is denoted by","category":"page"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"k(ymid x) = mathcalN(y  mu(x)   Sigma(x) )","category":"page"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"As with the Normal distributions, the explicit expression on the kernel depends on whether it is real or complex valued.","category":"page"},{"location":"kernels/normalkernel/#Types","page":"NormalKernel","title":"Types","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"AbstractNormalKernel{T}\nNormalKernel{T}","category":"page"},{"location":"kernels/normalkernel/#MarkovKernels.AbstractNormalKernel","page":"NormalKernel","title":"MarkovKernels.AbstractNormalKernel","text":"AbstractNormalKernel{T<:Number}\n\nAbstract type for representing Normal kernels taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel\n\nStandard mean vector / covariance matrix parametrisation of Normal kernels.\n\n\n\n\n\n","category":"type"},{"location":"kernels/normalkernel/#Type-aliases","page":"NormalKernel","title":"Type aliases","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"const AffineNormalKernel{T} = NormalKernel{T,<:AbstractAffineMap,<:CovarianceParameter}","category":"page"},{"location":"kernels/normalkernel/#Constructors","page":"NormalKernel","title":"Constructors","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ)\nNormalKernel(Φ::AbstractMatrix, Σ)\nNormalKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\nNormalKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\nNormalKernel(F::AbstractAffineMap, Σ::CovarianceParameter)\nNormalKernel(F::AbstractAffineMap, Σ::AbstractMatrix)\nNormalKernel{T}(K::AffineNormalKernel{U}) where {T,U}","category":"page"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ)\n\nCreates a NormalKernel with conditional mean function F and conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with F.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, Σ)\n\nCreates a NormalKernel with a linear conditional mean function given by\n\nx ↦ Φ * x,\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, AbstractVector, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\n\nCreates a NormalKernel with an affine conditional mean function given by\n\nx ↦ b + Φ * x,\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ, b.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, AbstractVector, AbstractVector, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\n\nCreates a NormalKernel with an affine corrector conditional mean function given by\n\nx ↦ b + Φ * (x - c),\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ, b, c.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, Union{LinearAlgebra.Factorization{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ::CovarianceParameter)\n\nCreates a NormalKernel with conditional mean function F and a constant conditional covariance function parameterised by Σ.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, AbstractMatrix}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ::AbstractMatrix)\n\nCreates a NormalKernel with conditional mean function F and a constant conditional covariance function Σ if Σ is Symmetric / Hermitian. Throws domain error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.NormalKernel-Union{Tuple{AffineNormalKernel{U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel{T}(K::AffineNormalKernel{U}) where {T,U}\n\nComputes a Normal kernel of eltype T from the Normal kernel K if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#Basics","page":"NormalKernel","title":"Basics","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"mean(K::NormalKernel)\ncov(K::NormalKernel)\ncovp(K::NormalKernel)","category":"page"},{"location":"kernels/normalkernel/#Statistics.mean-Tuple{NormalKernel}","page":"NormalKernel","title":"Statistics.mean","text":"mean(K::AbstractNormalKernel)\n\nComputes the conditonal mean function of the Normal kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#Statistics.cov-Tuple{NormalKernel}","page":"NormalKernel","title":"Statistics.cov","text":"mean(K::AbstractNormalKernel)\n\nComputes the conditonal covariance matrix function of the Normal kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#MarkovKernels.covp-Tuple{NormalKernel}","page":"NormalKernel","title":"MarkovKernels.covp","text":"covp(K::AbstractNormalKernel)\n\nReturns the internal representation of the conditonal covariance matrix of the Normal kernel K. For computing the actual conditional covariance matrix, use cov.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#Conditioning-and-sampling","page":"NormalKernel","title":"Conditioning and sampling","text":"","category":"section"},{"location":"kernels/normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"condition(K::AbstractNormalKernel, x)\nrand(RNG::AbstractRNG, K::AbstractNormalKernel, x::AbstractVector)\nrand(K::AbstractNormalKernel, x::AbstractVector)","category":"page"},{"location":"kernels/normalkernel/#MarkovKernels.condition-Tuple{AbstractNormalKernel, Any}","page":"NormalKernel","title":"MarkovKernels.condition","text":"condition(K::AbstractNormalKernel, x)\n\nReturns a Normal distribution corresponding to K evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#Base.rand-Tuple{Random.AbstractRNG, AbstractNormalKernel, AbstractVector}","page":"NormalKernel","title":"Base.rand","text":"rand(RNG::AbstractRNG, K::AbstractNormalKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Normal kernel K using the random number generator RNG.\n\n\n\n\n\n","category":"method"},{"location":"kernels/normalkernel/#Base.rand-Tuple{AbstractNormalKernel, AbstractVector}","page":"NormalKernel","title":"Base.rand","text":"rand(K::AbstractNormalKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Normal kernel K using the random number generator Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"method"},{"location":"tutorial_pomp_sampling/#Sampling-from-Markov-realisable-processes","page":"Sampling from probabilistic state-space models","title":"Sampling from Markov-realisable processes","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"This tutorial describes how to sample from the probabilistic state-space model given by","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"beginaligned\nx_0 sim mathcalN(mu_0 Sigma_0) \nx_n mid x_n-1 sim mathcalN(Phi  x_n-1 Q)\nz_n = C x_n\nendaligned","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"where x and z are referred to as the latent Gauss-Markov process and the output process, respectively. Additionally, noisy measurements of the output process will be generated according to","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"y_n mid x_n sim mathcalN(Cx_nR)","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-a-Gauss-Markov-process","page":"Sampling from probabilistic state-space models","title":"Sampling a Gauss-Markov process","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"using MarkovKernels\nusing Random, LinearAlgebra, Plots, IterTools\n\n# sample a homogeneous Markov model\nfunction sample(rng, init, K, nstep)\n    x = rand(rng, init)\n    it = Iterators.take(iterated(z -> rand(rng, K, z), x), nstep + 1)\n    return mapreduce(permutedims, vcat, collect(it))\nend","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-latent-states","page":"Sampling from probabilistic state-space models","title":"Sampling latent states","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"# set rng\nrng = MersenneTwister(1991)\n\n# time grid\nm = 200\nT = 5\nts = collect(LinRange(0, T, m))\ndt = T / (m - 1)\n\n# transtion kernel\nλ = 2.0\nΦ = exp(-λ * dt) .* [1.0 0.0; -2*λ*dt 1.0]\nQ = I - exp(-2 * λ * dt) .* [1.0 -2*λ*dt; -2*λ*dt 1+(2*λ*dt)^2]\nfw_kernel = NormalKernel(Φ, Q)\n\n# initial distribution\ninit = Normal(zeros(2), 1.0I(2))\n\n# sample state\nxs = sample(rng, init, fw_kernel, m - 1)\n\nstate_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = \"t\",\n    labels = [\"x1\" \"x2\"],\n    title = [\"Latent Gauss-Markov process\" \"\"],\n)","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-and-plotting-the-output","page":"Sampling from probabilistic state-space models","title":"Sampling and plotting the output","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"# output kernel and measurement kernel\nC = 1.0 / sqrt(2) * [1.0 -1.0]\noutput_kernel = DiracKernel(C)\nR = fill(0.1, 1, 1)\nm_kernel = compose(NormalKernel(1.0I(1), R), output_kernel)\n\n# sample output and its measurements\nouts = mapreduce(z -> rand(rng, output_kernel, xs[z, :]), vcat, 1:m)\nys = mapreduce(z -> rand(rng, m_kernel, xs[z, :]), vcat, 1:m)\n\noutput_plot = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")","category":"page"},{"location":"likelihoods/#Likelihood","page":"Likelihoods","title":"Likelihood","text":"","category":"section"},{"location":"likelihoods/","page":"Likelihoods","title":"Likelihoods","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"likelihoods/#Types","page":"Likelihoods","title":"Types","text":"","category":"section"},{"location":"likelihoods/","page":"Likelihoods","title":"Likelihoods","text":"Likelihood{U,V}","category":"page"},{"location":"likelihoods/#MarkovKernels.Likelihood","page":"Likelihoods","title":"MarkovKernels.Likelihood","text":"Likelihood{U,V}\n\nType for representing a log-likelihood associated with a kernel K(y, x) and a measurement y.\n\n\n\n\n\n","category":"type"},{"location":"likelihoods/#Constructors","page":"Likelihoods","title":"Constructors","text":"","category":"section"},{"location":"likelihoods/","page":"Likelihoods","title":"Likelihoods","text":"Likelihood(K::AbstractMarkovKernel, y)","category":"page"},{"location":"likelihoods/#MarkovKernels.Likelihood-Tuple{AbstractMarkovKernel, Any}","page":"Likelihoods","title":"MarkovKernels.Likelihood","text":"Likelihood(K::AbstractMarkovKernel, y)\n\nCreates a Likelihood with measurement kernel K and measurement y.\n\n\n\n\n\n","category":"method"},{"location":"likelihoods/#Basics","page":"Likelihoods","title":"Basics","text":"","category":"section"},{"location":"likelihoods/","page":"Likelihoods","title":"Likelihoods","text":"measurement_model(L::Likelihood)\nmeasurement(L::Likelihood)\nlog(L::Likelihood, x) ","category":"page"},{"location":"likelihoods/#MarkovKernels.measurement_model-Tuple{Likelihood}","page":"Likelihoods","title":"MarkovKernels.measurement_model","text":"measurement_model(L::Likelihood)\n\nComputes the measurement kernel K.\n\n\n\n\n\n","category":"method"},{"location":"likelihoods/#MarkovKernels.measurement-Tuple{Likelihood}","page":"Likelihoods","title":"MarkovKernels.measurement","text":"measurement(L::Likelihood)\n\nComputes the measurement y\n\n\n\n\n\n","category":"method"},{"location":"likelihoods/#Base.log-Tuple{Likelihood, Any}","page":"Likelihoods","title":"Base.log","text":"log(L::Likelihood, x)\n\nComputes the logarithm of the likelihood L at x. \n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#ParticleSystem","page":"ParticleSystem","title":"ParticleSystem","text":"","category":"section"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"A Particle system is a mixture of Dirac distributions.","category":"page"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"P(x) = sum_i= 1^n w_i delta(x - μ^(i))","category":"page"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"It can also be used to represent a mixture of trajectories.","category":"page"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"P(x) = sum_i= 1^n w_i delta(x_1T - μ^(i)_1T)","category":"page"},{"location":"distributions/particle_system/#Types","page":"ParticleSystem","title":"Types","text":"","category":"section"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"AbstractParticleSystem{T}\nParticleSystem{T}","category":"page"},{"location":"distributions/particle_system/#MarkovKernels.AbstractParticleSystem","page":"ParticleSystem","title":"MarkovKernels.AbstractParticleSystem","text":"AbstractParticleSystem{T} <: AbstractDistribution{T}\n\nabstract type for representing systems of particles.\n\n\n\n\n\n","category":"type"},{"location":"distributions/particle_system/#MarkovKernels.ParticleSystem","page":"ParticleSystem","title":"MarkovKernels.ParticleSystem","text":"ParticleSystem{T,A,B} <: AbstractParticleSystem{T}\n\ntype for representing a standard particle system.\n\n\n\n\n\n","category":"type"},{"location":"distributions/particle_system/#Constructors","page":"ParticleSystem","title":"Constructors","text":"","category":"section"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"ParticleSystem(logws::AbstractVector{<:Real}, X::AbstractArray{<:AbstractVector{T}}) where {T}","category":"page"},{"location":"distributions/particle_system/#MarkovKernels.ParticleSystem-Union{Tuple{T}, Tuple{AbstractVector{<:Real}, AbstractArray{<:AbstractVector{T}}}} where T","page":"ParticleSystem","title":"MarkovKernels.ParticleSystem","text":"ParticleSystem(logws::AbstractVector{<:Real}, X::AbstractArray{<:AbstractVector{T}})\n\nCreates a ParticleSystem with logarithm of the mixture weights given by logws and location parameters in X. If X is an AbstractVector the resulting object represents a classical Dirac mixtrue. Whereas if X is an AbstractMatrix, the resulting object represents a Dirac mixture over trajectories, where the row dimension represents time and the column dimension enumerates the particles.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#Basics","page":"ParticleSystem","title":"Basics","text":"","category":"section"},{"location":"distributions/particle_system/","page":"ParticleSystem","title":"ParticleSystem","text":"dim(::ParticleSystem)\nlogweights(::ParticleSystem)\nweights(::ParticleSystem)\nnparticles(::ParticleSystem)\nparticles(::ParticleSystem)\nmean(::ParticleSystem)","category":"page"},{"location":"distributions/particle_system/#MarkovKernels.dim-Tuple{ParticleSystem}","page":"ParticleSystem","title":"MarkovKernels.dim","text":"dim(P::AbstractParticleSystem)\n\nReturns the dimension of the particle system distribution P.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#MarkovKernels.logweights-Tuple{ParticleSystem}","page":"ParticleSystem","title":"MarkovKernels.logweights","text":"logweights(P::AbstractParticleSystem)\n\nReturns the logarithms of the mixture weights of the particle system P.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#MarkovKernels.weights-Tuple{ParticleSystem}","page":"ParticleSystem","title":"MarkovKernels.weights","text":"weights(P::AbstractParticleSystem)\n\nReturns the mixture weights of the particle system P.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#MarkovKernels.nparticles-Tuple{ParticleSystem}","page":"ParticleSystem","title":"MarkovKernels.nparticles","text":"nparticles(P::AbstractParticleSystem)\n\nComputes the number of particles in the particle system P.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#MarkovKernels.particles-Tuple{ParticleSystem}","page":"ParticleSystem","title":"MarkovKernels.particles","text":"particles(P::AbstractParticleSystem)\n\nReturns the particle locations of the particle system P.\n\n\n\n\n\n","category":"method"},{"location":"distributions/particle_system/#Statistics.mean-Tuple{ParticleSystem}","page":"ParticleSystem","title":"Statistics.mean","text":"mean(P::AbstractParticleSystem)\n\nComputes the mean of the particle system distribution P.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"binary_operators/#composition","page":"Binary operators","title":"composition","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given Markov kernels k_2(yz) and k_1(zx), composition is a binary operator producing a third kernel k_3(yx) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"k_3(yx) = int k_2(yx) k_1(zx) mathrmd z","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"compose(K2::AffineNormalKernel{T}, K1::AffineNormalKernel{T}) where {T}","category":"page"},{"location":"binary_operators/#MarkovKernels.compose-Union{Tuple{T}, Tuple{AffineNormalKernel{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.compose","text":"compose(K2::AbstractMarkovKernel, K1::AbstractMarkovKernel)\n\nComputes K3, the composition of K2 ∘ K1 i.e.,\n\nK3(y,x) = ∫ K2(y,z) K1(z,x) dz.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#marginalization","page":"Binary operators","title":"marginalization","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given a distribution pi(x) and a Markov kernel k(yx), marginalization is a binary operator producing a new distriubution p(y) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"p(y) = int k(y x) pi(x) mathrmd x","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"marginalize(N::AbstractNormal{T}, K::AffineNormalKernel{T}) where {T}","category":"page"},{"location":"binary_operators/#MarkovKernels.marginalize-Union{Tuple{T}, Tuple{AbstractNormal{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.marginalize","text":"marginalise(D::AbstractDistribution, K::AbstractMarkovKernel)\n\nComputes M, the marginalisation of K with respect to D, i.e.,\n\nM(y) = ∫ K(y,x)D(x) dx\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#invert-and-Bayes'-rule","page":"Binary operators","title":"invert & Bayes' rule","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given a distribution pi(x) and a Markov kernel k(yx), invert is a binary operator producing a new distribution m(y) and a new Markov kernel p(x  y) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"pi(x) k(yx) = m(y) p(xy)","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"The related binary operator, Bayes' rule also evalautes the output of invert at some measurement y. That is, given a measurmeent y, m evaluated at y is the marginal likelihood and p evaluated at y is the conditional distribution of x given y.","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"invert(N::AbstractNormal{T}, K::AffineNormalKernel{T}) where {T}\nbayes_rule(D::AbstractDistribution, K::AbstractMarkovKernel, y)\nbayes_rule(D::AbstractDistribution, L::AbstractLikelihood)\nbayes_rule!(P::ParticleSystem{T,U,<:AbstractVector}, L::AbstractLikelihood) where {T,U}","category":"page"},{"location":"binary_operators/#MarkovKernels.invert-Union{Tuple{T}, Tuple{AbstractNormal{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.invert","text":"invert(D::AbstractDistribution, K::AbstractMarkovKernel)\n\nComputes D2, K2, such that D(x)K(y, x) = D2(y)K2(x, y), i.e., an inverted factorisation of D, K.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#MarkovKernels.bayes_rule-Tuple{AbstractDistribution, AbstractMarkovKernel, Any}","page":"Binary operators","title":"MarkovKernels.bayes_rule","text":"bayes_rule(D::AbstractDistribution, K::AbstractMarkovKernel, y)\n\nComputes the conditional distribution C and the marginal log-likelihood ℓ associated with the prior distribution D, measurement kernel K, and measurement y.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#MarkovKernels.bayes_rule-Tuple{AbstractDistribution, AbstractLikelihood}","page":"Binary operators","title":"MarkovKernels.bayes_rule","text":"bayes_rule(D::AbstractDistribution, L::AbstractLikelihood)\n\nComputes the conditional distribution C and the marginal log-likelihood ℓ associated with the prior distribution D and the log-likelihood L.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#MarkovKernels.bayes_rule!-Union{Tuple{U}, Tuple{T}, Tuple{ParticleSystem{T, U, <:AbstractVector}, AbstractLikelihood}} where {T, U}","page":"Binary operators","title":"MarkovKernels.bayes_rule!","text":"bayes_rule!(D::AbstractParticleSystem, L::AbstractLikelihood)\n\nComputes the conditional distribution C in-place and the marginal log-likelihood ℓ associated with the prior distribution D and the log-likelihood L.\n\n\n\n\n\n","category":"method"},{"location":"tutorial_bootstrap/#Bootstrap-filtering-and-smoothing","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"This tutorial describes how to perform filtering and smoothing in a the probabilistic state-space model given by","category":"page"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"beginaligned\nx_0 sim mathcalN(mu_0 Sigma_0) \nx_n mid x_n-1 sim mathcalN(Phi  x_n-1 Q)\nz_n = C x_n\nendaligned","category":"page"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"subject to the measurements given by","category":"page"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"y_n mid x_n sim mathcalN(0 e^z_n)","category":"page"},{"location":"tutorial_bootstrap/#Setting-up-the-environment-and-generating-some-data","page":"Bootstrap filtering and smoothing","title":"Setting up the environment and generating some data","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"using MarkovKernels\nusing LinearAlgebra, Plots, Random\nusing IterTools\nimport StatsBase: wsample\n\nrng = MersenneTwister(1991)\n\nfunction sample(rng, init, K, nstep)\n    it = Iterators.take(iterated(z -> rand(rng, K, z), rand(rng, init)), nstep + 1)\n    return mapreduce(permutedims, vcat, collect(it))\nend\n\n# time grid\nm = 50\nT = 5\nts = collect(LinRange(0, T, m))\ndt = T / (m - 1)\n\n# define transtion kernel\nλ = 1.0\nΦ = exp(-λ * dt) .* [1.0 0.0; -2*λ*dt 1.0]\nQ = I - exp(-2 * λ * dt) .* [1.0 -2*λ*dt; -2*λ*dt 1+(2*λ*dt)^2]\nfw_kernel = NormalKernel(Φ, Q)\n\n# initial distribution\ninit = Normal(zeros(2), 1.0I(2))\n\n# sample state\nxs = sample(rng, init, fw_kernel, m - 1)\n\n# output kernel\nσ = 5.0\nC = σ / sqrt(2) * [1.0 -1.0]\n\noutput_kernel = DiracKernel(C)\n\nvariance(x) = fill(exp.(x)[1], 1, 1)\nm_kernel = compose(NormalKernel(zeros(1, 1), variance), output_kernel)\n\n# sample output\nzs = mapreduce(z -> rand(rng, output_kernel, xs[z, :]), vcat, 1:m)\nys = mapreduce(z -> rand(rng, m_kernel, xs[z, :]), vcat, 1:m)\n\nmeasurement_plt = scatter(ts, ys, label = \"measurements\", color = \"black\")","category":"page"},{"location":"tutorial_bootstrap/#Implementing-a-bootstrap-filter","page":"Bootstrap filtering and smoothing","title":"Implementing a bootstrap filter","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"function bootstrap_filter(\n    rng::AbstractRNG,\n    ys::AbstractVecOrMat,\n    init::AbstractDistribution,\n    fw_kernel::AbstractMarkovKernel,\n    m_kernel::AbstractMarkovKernel,\n    K::Integer,\n)\n\n    # initialize\n    X = [rand(rng, init) for k in 1:K]\n    P = ParticleSystem(zeros(K), X)\n    loglike = 0.0\n    L = Likelihood(m_kernel, ys[1, :])\n    loglike_incr = bayes_rule!(P, L)\n    loglike = loglike + loglike_incr\n    resample!(rng, P)\n\n    Ps = [P]\n    sizehint!(Ps, size(ys, 1))\n\n    for m in 2:size(ys, 1)\n        L = Likelihood(m_kernel, ys[m, :])\n        P = predict(rng, P, fw_kernel)\n        loglike_incr = bayes_rule!(P, L)\n        loglike = loglike + loglike_incr\n        resample!(rng, P)\n        push!(Ps, P)\n    end\n\n    return Ps, loglike\nend\n\nfunction resample!(rng::AbstractRNG, P::ParticleSystem{T,U,<:AbstractVector}) where {T,U}\n    idx = wsample(rng, eachindex(logweights(P)), weights(P), nparticles(P))\n    logweights(P)[:] .= zero(logweights(P))\n    particles(P)[:] .= particles(P)[idx]\nend\n\nfunction predict(\n    rng::AbstractRNG,\n    P::ParticleSystem{T,U,<:AbstractVector},\n    K::AbstractMarkovKernel,\n) where {T,U}\n    X = [rand(rng, K, particles(P)[i]) for i in eachindex(particles(P))]\n\n    return ParticleSystem(copy(logweights(P)), X)\nend","category":"page"},{"location":"tutorial_bootstrap/#Computing-the-filtered-state-estimates","page":"Bootstrap filtering and smoothing","title":"Computing the filtered state estimates","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"K = 500\nPfilt, loglike_filt = bootstrap_filter(rng, ys, init, fw_kernel, m_kernel, K)\n\nXfilt = mapreduce(permutedims, vcat, particles.(Pfilt))\n\nstate_filt_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = \"t\",\n    labels = [\"x1\" \"x2\"],\n    title = [\"Latent Gauss-Markov process\" \"\"],\n)\nfor k in 1:K\n    scatter!(\n        ts,\n        mapreduce(permutedims, vcat, Xfilt[:, k]),\n        markersize = 1,\n        color = \"red\",\n        alpha = 0.025,\n        label = \"\",\n    )\nend\nstate_filt_plt","category":"page"},{"location":"tutorial_bootstrap/#Computing-the-filtered-output-estimates","page":"Bootstrap filtering and smoothing","title":"Computing the filtered output estimates","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"bf_output_filt = [marginalize(Pfilt[i], output_kernel) for i in eachindex(Pfilt)]\nZfilt = getindex.(mapreduce(permutedims, vcat, particles.(bf_output_filt)), 1)\n\noutput_filt_plt = plot(ts, zs, label = \"output\", xlabel = \"t\", title = \"log-variance\")\nscatter!(ts, Zfilt, markersize = 1, color = \"red\", alpha = 0.01, label = \"\")\noutput_filt_plt","category":"page"},{"location":"tutorial_bootstrap/#Implementing-a-bootstrap-smoother","page":"Bootstrap filtering and smoothing","title":"Implementing a bootstrap smoother","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"function bootstrap_smoother(\n    rng::AbstractRNG,\n    ys::AbstractVecOrMat,\n    init::AbstractDistribution,\n    fw_kernel::AbstractMarkovKernel,\n    m_kernel::AbstractMarkovKernel,\n    K::Integer,\n)\n\n    # initialize\n    X = permutedims([rand(rng, init) for k in 1:K])\n    P = ParticleSystem(zeros(K), X)\n    loglike = 0.0\n    L = Likelihood(m_kernel, ys[1, :])\n    loglike_incr = bayes_rule!(P, L)\n    loglike = loglike + loglike_incr\n    resample!(rng, P)\n\n    for m in 2:size(ys, 1)\n        L = Likelihood(m_kernel, ys[m, :])\n\n        P = predict(rng, P, fw_kernel)\n        loglike_incr = bayes_rule!(P, L)\n\n        loglike = loglike + loglike_incr\n        resample!(rng, P)\n    end\n\n    return P, loglike\nend\n\nfunction resample!(rng::AbstractRNG, P::ParticleSystem{T,U,<:AbstractMatrix}) where {T,U}\n    idx = wsample(rng, eachindex(logweights(P)), weights(P), nparticles(P))\n    logweights(P)[:] .= zero(logweights(P))\n    particles(P)[:, :] .= particles(P)[:, idx]\nend\n\nfunction predict(\n    rng::AbstractRNG,\n    P::ParticleSystem{T,U,<:AbstractMatrix},\n    K::AbstractMarkovKernel,\n) where {T,U}\n\n    X = [rand(rng, K, particles(P)[end, i]) for i in 1:nparticles(P)]\n\n    return ParticleSystem(logweights(P), vcat(particles(P), permutedims(X)))\nend","category":"page"},{"location":"tutorial_bootstrap/#Computing-the-smoothed-state-estimates","page":"Bootstrap filtering and smoothing","title":"Computing the smoothed state estimates","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"Psmooth, loglike_smooth = bootstrap_smoother(rng, ys, init, fw_kernel, m_kernel, K)\n\nXsmooth = particles(Psmooth)\n\nbf_output_smooth = marginalize(Psmooth, output_kernel)\nYsmooth = getindex.(particles(bf_output_smooth), 1)\n\nstate_smooth_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = \"t\",\n    labels = [\"x1\" \"x2\"],\n    title = [\"Latent Gauss-Markov process\" \"\"],\n)\nfor k in 1:K\n    plot!(\n        ts,\n        mapreduce(permutedims, vcat, Xsmooth[:, k]),\n        color = \"green\",\n        alpha = 0.025,\n        label = \"\",\n    )\nend\nstate_smooth_plt","category":"page"},{"location":"tutorial_bootstrap/#Computing-the-smoothed-output-estimate","page":"Bootstrap filtering and smoothing","title":"Computing the smoothed output estimate","text":"","category":"section"},{"location":"tutorial_bootstrap/","page":"Bootstrap filtering and smoothing","title":"Bootstrap filtering and smoothing","text":"bf_output_smooth = marginalize(Psmooth, output_kernel)\nZsmooth = getindex.(particles(bf_output_smooth), 1)\n\noutput_smooth_plt = plot(ts, zs, label = \"output\", xlabel = \"t\", title = \"log-variance\")\nplot!(ts, Zsmooth, color = \"green\", alpha = 0.025, label = \"\")\noutput_smooth_plt","category":"page"},{"location":"distributions/dirac/#Dirac","page":"Dirac","title":"Dirac","text":"","category":"section"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"The Dirac distribution with parameter mu is a distribution putting all probabiltiy mass on mu. It is denoted by","category":"page"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"delta(x -mu)","category":"page"},{"location":"distributions/dirac/#Types","page":"Dirac","title":"Types","text":"","category":"section"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"AbstractDirac{T}\nDirac{T}","category":"page"},{"location":"distributions/dirac/#MarkovKernels.AbstractDirac","page":"Dirac","title":"MarkovKernels.AbstractDirac","text":"AbstractDirac{T<:Number}\n\nAbstract type for representing Dirac random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"distributions/dirac/#MarkovKernels.Dirac","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac{T<:Number}\n\nType for representing Dirac random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"distributions/dirac/#Constructors","page":"Dirac","title":"Constructors","text":"","category":"section"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"Dirac(μ::AbstractVector)\nDirac{T}(D::Dirac{U,V}) where {T,U,V<:AbstractVector}","category":"page"},{"location":"distributions/dirac/#MarkovKernels.Dirac-Tuple{AbstractVector}","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac{T}(D::Dirac{U,V})\n\nComputes a Dirac distribution of eltype T from the Dirac distribution D if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"distributions/dirac/#MarkovKernels.Dirac-Union{Tuple{Dirac{U, V}}, Tuple{V}, Tuple{U}, Tuple{T}} where {T, U, V<:(AbstractVector)}","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac{T}(D::Dirac{U,V})\n\nComputes a Dirac distribution of eltype T from the Dirac distribution D if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"distributions/dirac/#Basics","page":"Dirac","title":"Basics","text":"","category":"section"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"dim(::Dirac)\nmean(::Dirac)","category":"page"},{"location":"distributions/dirac/#MarkovKernels.dim-Tuple{Dirac}","page":"Dirac","title":"MarkovKernels.dim","text":"dim(D::AbstractDirac)\n\nReturns the dimension of the Dirac distribution D.\n\n\n\n\n\n","category":"method"},{"location":"distributions/dirac/#Statistics.mean-Tuple{Dirac}","page":"Dirac","title":"Statistics.mean","text":"mean(D::AbstractDirac)\n\nComputes the mean vector of the Dirac distribution D.\n\n\n\n\n\n","category":"method"},{"location":"distributions/dirac/#Sampling","page":"Dirac","title":"Sampling","text":"","category":"section"},{"location":"distributions/dirac/","page":"Dirac","title":"Dirac","text":"rand(::AbstractRNG, ::AbstractDirac)\nrand( ::AbstractDirac)","category":"page"},{"location":"distributions/dirac/#Base.rand-Tuple{Random.AbstractRNG, AbstractDirac}","page":"Dirac","title":"Base.rand","text":"rand(RNG::AbstractRNG, D::AbstractDirac)\n\nComputes a random vector distributed according to the Dirac distribution D using the random number generator RNG. Equivalent to mean(D).\n\n\n\n\n\n","category":"method"},{"location":"distributions/dirac/#Base.rand-Tuple{AbstractDirac}","page":"Dirac","title":"Base.rand","text":"rand(D::AbstractDirac)\n\nComputes a random vector distributed according to the Dirac distribution D using the random number generator Random.GLOBAL_RNG. Equivalent to mean(D).\n\n\n\n\n\n","category":"method"},{"location":"tutorial_kalman_filter/#Kalman-filtering-and-smoothing","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"This tutorial describes how to perform filtering and smoothing in a the probabilistic state-space model given by","category":"page"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"beginaligned\nx_0 sim mathcalN(mu_0 Sigma_0) \nx_n mid x_n-1 sim mathcalN(Phi  x_n-1 Q)\nz_n = C x_n\nendaligned","category":"page"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"subject to the measurements given by","category":"page"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"y_n mid x_n sim mathcalN(Cx_nR)","category":"page"},{"location":"tutorial_kalman_filter/#Setting-up-the-environment-and-generating-some-data","page":"Kalman filtering and smoothing","title":"Setting up the environment and generating some data","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"using MarkovKernels\nusing Random, LinearAlgebra, Plots, IterTools\n\nrng = MersenneTwister(1991)\n\nfunction sample(rng, init, K, nstep)\n    it = Iterators.take(iterated(z -> rand(rng, K, z), rand(rng, init)), nstep + 1)\n    return mapreduce(permutedims, vcat, collect(it))\nend\n\n# time grid\nm = 200\nT = 5\nts = collect(LinRange(0, T, m))\ndt = T / (m - 1)\n\n# define transtion kernel\nλ = 2.0\nΦ = exp(-λ * dt) .* [1.0 0.0; -2*λ*dt 1.0]\nQ = I - exp(-2 * λ * dt) .* [1.0 -2*λ*dt; -2*λ*dt 1+(2*λ*dt)^2]\nfw_kernel = NormalKernel(Φ, Q)\n\n# initial distribution\ninit = Normal(zeros(2), diagm(ones(2)))\n\n# sample state\nxs = sample(rng, init, fw_kernel, m - 1)\n\n# output kernel and measurement kernel\nC = 1.0 / sqrt(2) * [1.0 -1.0]\noutput_kernel = DiracKernel(C)\nR = fill(0.1, 1, 1)\nm_kernel = compose(NormalKernel(1.0I(1), R), output_kernel)\n\n# sample output and its measurements\nzs = mapreduce(z -> rand(rng, output_kernel, xs[z, :]), vcat, 1:m)\nys = mapreduce(z -> rand(rng, m_kernel, xs[z, :]), vcat, 1:m)\n\noutput_plot = plot(ts, zs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")","category":"page"},{"location":"tutorial_kalman_filter/#Implementing-a-Kalman-filter","page":"Kalman filtering and smoothing","title":"Implementing a Kalman filter","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"function kalman_filter(\n    ys::AbstractVecOrMat,\n    init::AbstractNormal,\n    fw_kernel::AbstractNormalKernel,\n    m_kernel::AbstractNormalKernel,\n)\n\n    # initialise recursion\n    filter_distribution = init\n    filter_distributions = typeof(init)[]\n\n    # initial measurement update\n    likelihood = Likelihood(m_kernel, ys[1, :])\n    filter_distribution, loglike_increment = bayes_rule(filter_distribution, likelihood)\n    push!(filter_distributions, filter_distribution)\n    loglike = loglike_increment\n\n    for m in 2:size(ys, 1)\n\n        # predict\n        filter_distribution = marginalize(filter_distribution, fw_kernel)\n\n        # measurement update\n        likelihood = Likelihood(m_kernel, ys[m, :])\n        filter_distribution, loglike_increment = bayes_rule(filter_distribution, likelihood)\n        push!(filter_distributions, filter_distribution)\n        loglike = loglike + loglike_increment\n    end\n\n    return filter_distributions, loglike\nend","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-filtered-state-estimates","page":"Kalman filtering and smoothing","title":"Computing the filtered state estimates","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"filter_distributions, loglike = kalman_filter(ys, init, fw_kernel, m_kernel)\n\nstate_filter_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = [\"\" \"t\"],\n    label = [\"x1\" \"x2\"],\n    title = [\"Filter estimates of the state\" \"\"],\n)\nplot!(ts, filter_distributions, layout = (2, 1), label = [\"x1filter\" \"x2filter\"])","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-filtered-output-estimates","page":"Kalman filtering and smoothing","title":"Computing the filtered output estimates","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"output_filter_estimate = map(z -> marginalize(z, output_kernel), filter_distributions)\n\noutput_filter_plt = plot(ts, zs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")\nplot!(ts, output_filter_estimate, label = \"filter estimate\")","category":"page"},{"location":"tutorial_kalman_filter/#Implementing-a-Rauch-Tung-Striebel-recursion","page":"Kalman filtering and smoothing","title":"Implementing a Rauch-Tung-Striebel recursion","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"function rts(filter_distributions, fw_kernel)\n    smoother_distribution = filter_distributions[end]\n    smoother_distributions = similar(filter_distributions)\n    smoother_distributions[end] = smoother_distribution\n\n    for m in length(smoother_distributions)-1:-1:1\n        pred, bw_kernel = invert(filter_distributions[m], fw_kernel)\n        smoother_distribution = marginalize(smoother_distribution, bw_kernel)\n        smoother_distributions[m] = smoother_distribution\n    end\n\n    return smoother_distributions\nend","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-smoothed-state-estimate","page":"Kalman filtering and smoothing","title":"Computing the smoothed state estimate","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"smoother_distributions = rts(filter_distributions, fw_kernel)\n\nstate_smoother_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = [\"\" \"t\"],\n    label = [\"x1\" \"x2\"],\n    title = [\"Smoother estimates of the state\" \"\"],\n)\nplot!(ts, smoother_distributions, layout = (2, 1), label = [\"x1smoother\" \"x2smoother\"])","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-smoothed-output-estimate","page":"Kalman filtering and smoothing","title":"Computing the smoothed output estimate","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Kalman filtering and smoothing","title":"Kalman filtering and smoothing","text":"output_smoother_estimate = map(z -> marginalize(z, output_kernel), smoother_distributions)\noutput_smoother_plt = plot(ts, zs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")\nplot!(ts, output_smoother_estimate, label = \"smoother estimate\")","category":"page"},{"location":"kernels/dirackernel/#DiracKernel","page":"DiracKernel","title":"DiracKernel","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"The Dirac kernel with conditional mean prameter  mu is denotd by","category":"page"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"k(ymid x) = delta(y - mu(x))","category":"page"},{"location":"kernels/dirackernel/#Types","page":"DiracKernel","title":"Types","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"AbstractDiracKernel{T}\nDiracKernel{T}","category":"page"},{"location":"kernels/dirackernel/#MarkovKernels.AbstractDiracKernel","page":"DiracKernel","title":"MarkovKernels.AbstractDiracKernel","text":"AbstractDiracKernel{T<:Number}\n\nAbstract type for representing Dirac kernels taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel\n\nType for representing Dirac kernels K(y,x) = δ(y - μ(x)).\n\n\n\n\n\n","category":"type"},{"location":"kernels/dirackernel/#Type-aliases","page":"DiracKernel","title":"Type aliases","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"const AffineDiracKernel{T} = DiracKernel{T,<:AbstractAffineMap}","category":"page"},{"location":"kernels/dirackernel/#Constructors","page":"DiracKernel","title":"Constructors","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"DiracKernel(F::AbstractAffineMap)\nDiracKernel(Φ::AbstractMatrix)\nDiracKernel(Φ::AbstractMatrix, b::AbstractVector)\nDiracKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nDiracKernel{T}(K::AffineDiracKernel{U}) where {T,U}","category":"page"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractAffineMap}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(F::AbstractAffineMap)\n\nCreates a DiracKernel with conditional mean function F.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, Σ)\n\nCreates a DiracKernel with a linear conditional mean function given by\n\nx ↦ Φ * x.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix, AbstractVector}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\n\nCreates a DiracKernel with an affine conditional mean function given by\n\nx ↦ b + Φ * x.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix, AbstractVector, AbstractVector}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\n\nCreates a DiracKernel with an affine corrector conditional mean function given by\n\nx ↦ b + Φ * (x - c).\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#MarkovKernels.DiracKernel-Union{Tuple{AffineDiracKernel{U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel{T}(K::AffineDiracKernel{U}) where {T,U}\n\nComputes a Dirac kernel of eltype T from the Dirac kernel K if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#Basics","page":"DiracKernel","title":"Basics","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"mean(K::DiracKernel)","category":"page"},{"location":"kernels/dirackernel/#Statistics.mean-Tuple{DiracKernel}","page":"DiracKernel","title":"Statistics.mean","text":"mean(K::AbstractDiracKernel)\n\nComputes the conditonal mean function of the Dirac kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#Conditioning-and-sampling","page":"DiracKernel","title":"Conditioning and sampling","text":"","category":"section"},{"location":"kernels/dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"condition(K::DiracKernel, x)\nrand(::AbstractRNG, K::AbstractDiracKernel, x::AbstractVector)\nrand(K::AbstractDiracKernel, x::AbstractVector)","category":"page"},{"location":"kernels/dirackernel/#MarkovKernels.condition-Tuple{DiracKernel, Any}","page":"DiracKernel","title":"MarkovKernels.condition","text":"condition(K::AbstractDiracKernel, x)\n\nReturns a Dirac distribution corresponding to the Dirac kernel K evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#Base.rand-Tuple{Random.AbstractRNG, AbstractDiracKernel, AbstractVector}","page":"DiracKernel","title":"Base.rand","text":"rand(::AbstractRNG, K::AbstractDiracKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Dirac kernel K using the random number generator RNG. Equivalent to mean(K)(x).\n\n\n\n\n\n","category":"method"},{"location":"kernels/dirackernel/#Base.rand-Tuple{AbstractDiracKernel, AbstractVector}","page":"DiracKernel","title":"Base.rand","text":"rand(K::AbstractDiracKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Dirac kernel K using the random number generator Random.GLOBAL_RNG. Equivalent to mean(K)(x).\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#Covariance-Parameter","page":"Covariance parametrizations","title":"Covariance Parameter","text":"","category":"section"},{"location":"covariance_parameter/","page":"Covariance parametrizations","title":"Covariance parametrizations","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"covariance_parameter/","page":"Covariance parametrizations","title":"Covariance parametrizations","text":"In MarkovKernels.jl a covariance matrix is assumed to be of the following type union.","category":"page"},{"location":"covariance_parameter/","page":"Covariance parametrizations","title":"Covariance parametrizations","text":"const CovarianceParameter{T} = Union{HermOrSym{T},Factorization{T}}","category":"page"},{"location":"covariance_parameter/#Functions","page":"Covariance parametrizations","title":"Functions","text":"","category":"section"},{"location":"covariance_parameter/","page":"Covariance parametrizations","title":"Covariance parametrizations","text":"lsqrt(C::Cholesky)\nstein(Σ::HermOrSym, Φ::AbstractMatrix)\nstein(Σ::HermOrSym, Φ::AbstractMatrix, Q::HermOrSym)\nschur_reduce(Π::HermOrSym, C::AbstractMatrix)\nschur_reduce(Π::HermOrSym, C::AbstractMatrix, R::HermOrSym)","category":"page"},{"location":"covariance_parameter/#MarkovKernels.lsqrt-Tuple{LinearAlgebra.Cholesky}","page":"Covariance parametrizations","title":"MarkovKernels.lsqrt","text":"lsqrt(A::CovarianceParameter)\n\nComputes a square matrix L such that A = L*L'. L need not be a Cholesky factor.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.stein-Tuple{Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}, AbstractMatrix}","page":"Covariance parametrizations","title":"MarkovKernels.stein","text":"stein(Σ::CovarianceParameter, Φ::AbstractMatrix)\n\nComputes the output of the stein  operator\n\nΣ ↦ Φ * Σ * Φ'.\n\nThe type of CovarianceParameter is preserved at the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.stein-Tuple{Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}, AbstractMatrix, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}}","page":"Covariance parametrizations","title":"MarkovKernels.stein","text":"stein(Σ::CovarianceParameter, Φ::AbstractMatrix, Q::CovarianceParameter)\n\nComputes the output of the stein  operator\n\nΣ ↦ Φ * Σ * Φ' + Q.\n\nBoth Σ and Q need to be of the same CovarianceParameter type, e.g. both SymOrHerm or both Cholesky. The type of the CovarianceParameter is preserved at the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.schur_reduce-Tuple{Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}, AbstractMatrix}","page":"Covariance parametrizations","title":"MarkovKernels.schur_reduce","text":"schur_reduce(Π::CovarianceParameter, C::AbstractMatrix)\n\nReturns the tuple (S, K, Σ) associated with the following (block) Schur reduction:\n\n[C*Π*C' C*Π; Π*C' Π] = [0 0; 0 Σ] + [I; K]*(C*Π*C')*[I; K]'\n\nIn terms of Kalman filtering, Π is the predictive covariance, C the measurement matrix, and R the measurement covariance, then S is the marginal measurement covariance, K is the Kalman gain, and Σ is the filtering covariance. The type of the CovarianceParameter is preserved at the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.schur_reduce-Tuple{Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}, AbstractMatrix, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where {T, S}}","page":"Covariance parametrizations","title":"MarkovKernels.schur_reduce","text":"schur_reduce(Π::CovarianceParameter, C::AbstractMatrix, R::CovarianceParameter)\n\nReturns the tuple (S, K, Σ) associated with the following (block) Schur reduction:\n\n[CΠC' + R CΠ; ΠC' Π] = [0 0; 0 Σ] + [I; K](CΠC' + R)[I; K]'\n\nIn terms of Kalman filtering, Π is the predictive covariance, C the measurement matrix, and R the measurement covariance, then S is the marginal measurement covariance, K is the Kalman gain, and Σ is the filtering covariance. Both Π and R need to be of the same CovarianceParameter type, e.g. both SymOrHerm or both Cholesky. The type of the CovarianceParameter is preserved at the output.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Normal","page":"Normal","title":"Normal","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"The standard parametrisation of the Normal distribution is given by","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma )","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"where mu is the mean vector and Sigma is the covariance matrix. The exact expression for the probabiltiy density function depends on whether x is vector with real or complex values, both are supported. For real valued vectors the density function is given by","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma ) = 2pi Sigma^-12 exp Big(  -frac12(x-mu)^* Sigma^-1 (x-mu)  Big)","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"whereas for complex valued vectors the density function is given by","category":"page"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma ) = pi Sigma^-1 exp Big(  -(x-mu)^* Sigma^-1 (x-mu)  Big)","category":"page"},{"location":"distributions/normal/#Types","page":"Normal","title":"Types","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"AbstractNormal{T}\nNormal{T}","category":"page"},{"location":"distributions/normal/#MarkovKernels.AbstractNormal","page":"Normal","title":"MarkovKernels.AbstractNormal","text":"AbstractNormal{T<:Number}\n\nAbstract type for representing Normal distributed random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"distributions/normal/#MarkovKernels.Normal","page":"Normal","title":"MarkovKernels.Normal","text":"Normal{T,U,V}\n\nStandard mean vector / covariance matrix parametrisation of the normal distribution with element type T.\n\n\n\n\n\n","category":"type"},{"location":"distributions/normal/#Constructors","page":"Normal","title":"Constructors","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"Normal(μ::AbstractVector, Σ::CovarianceParameter)\nNormal(μ::AbstractVector, Σ::AbstractMatrix)\nNormal{T}(N::Normal{U,V,W}) where {T,U,V<:AbstractVector,W<:CovarianceParameter}","category":"page"},{"location":"distributions/normal/#MarkovKernels.Normal-Tuple{AbstractVector, Union{LinearAlgebra.Factorization{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal(μ::AbstractVector, Σ::CovarianceParameter)\n\nCreates a Normal distribution with mean vector μ and covariance matrix parametrised by Σ.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#MarkovKernels.Normal-Tuple{AbstractVector, AbstractMatrix}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal(μ::AbstractVector, Σ::AbstractMatrix)\n\nCreates a Normal distribution with mean vector μ and covariance matrix Σ if Σ is Symmetric / Hermitian. Throws domain error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#MarkovKernels.Normal-Union{Tuple{Normal{U, V, W}}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}} where {T, U, V<:(AbstractVector), W<:(Union{LinearAlgebra.Factorization{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T)}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal{T}(N::Normal{U,V,W})\n\nComputes a Normal distribution of eltype T from the Normal distribution N if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Basics","page":"Normal","title":"Basics","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"dim(::Normal)\nmean(::Normal)\ncov(::Normal)\ncovp(::Normal)\nvar(::AbstractNormal)\nstd(::AbstractNormal)","category":"page"},{"location":"distributions/normal/#MarkovKernels.dim-Tuple{Normal}","page":"Normal","title":"MarkovKernels.dim","text":"dim(N::AbstractNormal)\n\nReturns the dimension of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Statistics.mean-Tuple{Normal}","page":"Normal","title":"Statistics.mean","text":"mean(N::AbstractNormal)\n\nComputes the mean vector of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Statistics.cov-Tuple{Normal}","page":"Normal","title":"Statistics.cov","text":"cov(N::AbstractNormal)\n\nComputes the covariance matrix of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#MarkovKernels.covp-Tuple{Normal}","page":"Normal","title":"MarkovKernels.covp","text":"covp(N::AbstractNormal)\n\nReturns the internal representation of the covariance matrix of the Normal distribution N. For computing the actual covariance matrix, use cov.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Statistics.var-Tuple{AbstractNormal}","page":"Normal","title":"Statistics.var","text":"var(N::AbstractNormal)\n\nComputes the vector of marginal variances of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Statistics.std-Tuple{AbstractNormal}","page":"Normal","title":"Statistics.std","text":"std(N::AbstractNormal)\n\nComputes the vector of marginal standard deviations of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Probability-density-function","page":"Normal","title":"Probability density function","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"residual(N::AbstractNormal, x::AbstractVector)\nlogpdf(N::AbstractNormal, x)","category":"page"},{"location":"distributions/normal/#MarkovKernels.residual-Tuple{AbstractNormal, AbstractVector}","page":"Normal","title":"MarkovKernels.residual","text":"residual(N::AbstractNormal, x::AbstractVector)\n\nComputes the whitened residual associated with the Normal distribution N and observed vector x.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#MarkovKernels.logpdf-Tuple{AbstractNormal, Any}","page":"Normal","title":"MarkovKernels.logpdf","text":"logpdf(N::AbstractNormal,x)\n\nComputes the logarithm of the probability density function of the Normal distribution N evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Information-theory","page":"Normal","title":"Information theory","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"entropy(::AbstractNormal)\nkldivergence(N1::AbstractNormal{T}, N2::AbstractNormal{T}) where {T<:Number}","category":"page"},{"location":"distributions/normal/#MarkovKernels.entropy-Tuple{AbstractNormal}","page":"Normal","title":"MarkovKernels.entropy","text":"entropy(N::AbstractNormal)\n\nComputes the entropy of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#MarkovKernels.kldivergence-Union{Tuple{T}, Tuple{AbstractNormal{T}, AbstractNormal{T}}} where T<:Number","page":"Normal","title":"MarkovKernels.kldivergence","text":"kldivergence(N1::AbstractNormal, N2::AbstractNormal)\n\nComputes the Kullback-Leibler divergence between the Normal distributions N1 and N2.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Sampling","page":"Normal","title":"Sampling","text":"","category":"section"},{"location":"distributions/normal/","page":"Normal","title":"Normal","text":"rand(::AbstractRNG, ::AbstractNormal)\nrand( ::AbstractNormal)","category":"page"},{"location":"distributions/normal/#Base.rand-Tuple{Random.AbstractRNG, AbstractNormal}","page":"Normal","title":"Base.rand","text":"rand(RNG::AbstractRNG, N::AbstractNormal)\n\nComputes a random vector distributed according to the Normal distribution N using the random number generator RNG.\n\n\n\n\n\n","category":"method"},{"location":"distributions/normal/#Base.rand-Tuple{AbstractNormal}","page":"Normal","title":"Base.rand","text":"rand(N::AbstractNormal)\n\nComputes a random vector distributed according to the Normal distribution N using the random number generator Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MarkovKernels\nusing MarkovKernels","category":"page"},{"location":"#MarkovKernels","page":"Home","title":"MarkovKernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MarkovKernels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
